"""
ä½œè€…ï¼š cy
ç¬¬å…«ç« ï¼šå¾ªç¯ç¥ç»ç½‘ç»œ

å¦‚æœè¯´å·ç§¯ç¥ç»ç½‘ç»œå¯ä»¥æœ‰æ•ˆåœ°å¤„ç†ç©ºé—´ä¿¡æ¯ï¼Œé‚£ä¹ˆæœ¬ç« çš„å¾ªç¯ç¥ç»ç½‘ç»œï¼ˆrecurrent neural networkï¼Œ
RNNï¼‰åˆ™å¯ä»¥æ›´å¥½åœ°å¤„ç†åºåˆ—ä¿¡æ¯ã€‚å¾ªç¯ç¥ç»ç½‘ç»œé€šè¿‡å¼•å…¥çŠ¶æ€å˜é‡å­˜å‚¨è¿‡å»çš„ä¿¡æ¯å’Œå½“å‰çš„è¾“å…¥ï¼Œä»è€Œå¯
ä»¥ç¡®å®šå½“å‰çš„è¾“å‡ºã€‚

8.1 åºåˆ—æ¨¡å‹
è¯¥éƒ¨åˆ†ä½¿ç”¨çš„æ˜¯å›å½’é¢„æµ‹ï¼Œä¼šå¸¦æ¥è¾ƒå¤§çš„ç´¯ç§¯è¯¯å·®ï¼Œå¯¼è‡´é¢„æµ‹æ•ˆæœä¸å¤ªå¥½ï¼Œä¸‹é¢çš„å†…å®¹å¯èƒ½ä¼šæ¶‰åŠåˆ°å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜
å¤„ç†åºåˆ—æ•°æ®éœ€è¦ç»Ÿè®¡å·¥å…·å’Œæ–°çš„æ·±åº¦ç¥ç»ç½‘ç»œæ¶æ„ã€‚
è‡ªå›å½’æ¨¡å‹ï¼šxtâˆ’1, . . . , xtâˆ’Ï„
éšå˜é‡è‡ªå›å½’æ¨¡å‹ï¼šè¿‡å»è§‚æµ‹çš„æ€»ç»“htï¼Œä»¥åŠå…¬å¼ht = g(htâˆ’1, xtâˆ’1)æ›´æ–°çš„æ¨¡å‹
é©¬å°”å¯å¤«æ¨¡å‹
"""
import torch
from torch import nn
import matplotlib.pyplot as plt
from torch.utils import data


def load_array(data_arrays, batch_size, is_train=True):
    """æ„é€ ä¸€ä¸ªPyTorchæ•°æ®è¿­ä»£å™¨"""
    dataset = data.TensorDataset(*data_arrays)
    return data.DataLoader(dataset, batch_size, shuffle=is_train)


def plot_predictions(time, x, onestep_preds, multistep_preds, n_train, tau):
    """
    ç»˜åˆ¶æ—¶é—´åºåˆ—é¢„æµ‹ç»“æœ

    å‚æ•°:
    time: æ—¶é—´åºåˆ—
    x: åŸå§‹æ•°æ®
    onestep_preds: ä¸€æ­¥é¢„æµ‹ç»“æœ
    multistep_preds: å¤šæ­¥é¢„æµ‹ç»“æœ
    n_train: è®­ç»ƒé›†å¤§å°
    tau: æ—¶é—´çª—å£å¤§å°
    """
    plt.figure(figsize=(6, 3))

    # ç»˜åˆ¶åŸå§‹æ•°æ®
    plt.plot(time, x.detach().numpy(),
             label='Data', color='blue', linewidth=1.5, alpha=0.8)

    # ç»˜åˆ¶ä¸€æ­¥é¢„æµ‹ï¼ˆä»tauå¼€å§‹ï¼‰
    plt.plot(time[tau:], onestep_preds.detach().numpy(),
             label='1-step preds', color='red', linestyle='--', linewidth=1.5)

    # ç»˜åˆ¶å¤šæ­¥é¢„æµ‹ï¼ˆä»n_train + tauå¼€å§‹ï¼‰
    plt.plot(time[n_train + tau:], multistep_preds[n_train + tau:].detach().numpy(),
             label='Multistep preds', color='green', linestyle='-.', linewidth=1.5)

    # æ·»åŠ è®­ç»ƒ/æµ‹è¯•åˆ†å‰²çº¿
    plt.axvline(x=n_train, color='gray', linestyle=':', alpha=0.7,
                label='Train/Test Split')

    plt.xlabel('Time', fontsize=12)
    plt.ylabel('x', fontsize=12)
    plt.title('Time Series Predictions Comparison', fontsize=14)
    plt.legend(fontsize=10)
    plt.xlim([1, 1000])
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()


def plot_single_step_predictions(time, x, onestep_preds, tau):
    """
    ç»˜åˆ¶ä¸€æ­¥é¢„æµ‹ç»“æœï¼ˆä¸“é—¨ä¸ºä½ çš„ä»£ç è®¾è®¡ï¼‰

    å‚æ•°:
    time: æ—¶é—´åºåˆ—
    x: åŸå§‹æ•°æ®
    onestep_preds: ä¸€æ­¥é¢„æµ‹ç»“æœ
    tau: æ—¶é—´çª—å£å¤§å°
    """
    plt.figure(figsize=(6, 3))

    # ç»˜åˆ¶åŸå§‹æ•°æ®
    plt.plot(time, x.detach().numpy(), label='data', linewidth=1.5)

    # ç»˜åˆ¶ä¸€æ­¥é¢„æµ‹ç»“æœ
    plt.plot(time[tau:], onestep_preds.detach().numpy(),
             linestyle='--', label='1-step preds', linewidth=1.5)

    plt.xlabel('time')
    plt.ylabel('x')
    plt.legend()
    plt.xlim([1, 1000])
    plt.grid(True, alpha=0.3)  # å¯é€‰ï¼šæ·»åŠ ç½‘æ ¼
    plt.tight_layout()
    plt.show()


def plot_multistep_predictions_fixed(time, features, steps, tau, max_steps):
    """
    ä¿®å¤ç‰ˆå¤šæ­¥é¢„æµ‹ç»˜å›¾å‡½æ•°
    """
    plt.figure(figsize=(8, 4))

    # è·å–ç‰¹å¾çŸ©é˜µä¿¡æ¯
    num_features = features.shape[1]

    # è‡ªåŠ¨è¿‡æ»¤æœ‰æ•ˆçš„steps
    valid_steps = []
    for i in steps:
        col_index = tau + i - 1
        if col_index < num_features:
            valid_steps.append(i)
        else:
            print(f"è­¦å‘Š: è·³è¿‡ step {i}ï¼Œéœ€è¦åˆ—ç´¢å¼• {col_index}ï¼Œä½†åªæœ‰ {num_features} åˆ—å¯ç”¨")

    if not valid_steps:
        print("é”™è¯¯: æ²¡æœ‰æœ‰æ•ˆçš„stepså¯ä»¥ç»˜åˆ¶ï¼")
        return

    print(f"å°†ç»˜åˆ¶ä»¥ä¸‹steps: {valid_steps}")

    # ä¸ºæ¯ä¸ªæœ‰æ•ˆstepç»˜åˆ¶æ›²çº¿
    for i in valid_steps:
        # æ—¶é—´èŒƒå›´
        start_time = tau + i - 1
        end_time = len(time) - max_steps + i
        time_range = time[start_time:end_time]

        # ç‰¹å¾æ•°æ®
        feature_data = features[:, (tau + i - 1)].detach().numpy()

        # ç¡®ä¿æ•°æ®é•¿åº¦åŒ¹é…
        min_len = min(len(time_range), len(feature_data))

        plt.plot(time_range[:min_len], feature_data[:min_len],
                 label=f'{i}-step preds', linewidth=1.5)

    plt.xlabel('time')
    plt.ylabel('x')
    plt.legend()
    plt.xlim([5, 1000])
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

# ä½¿ç”¨ä¸€ä¸ªç›¸å½“ç®€å•çš„æ¶æ„è®­ç»ƒæ¨¡å‹ï¼šä¸€ä¸ªæ‹¥æœ‰ä¸¤ä¸ªå…¨è¿æ¥å±‚çš„å¤šå±‚æ„ŸçŸ¥æœºï¼ŒReLUæ¿€æ´»å‡½æ•°å’Œå¹³æ–¹æŸå¤±ã€‚
# åˆå§‹åŒ–ç½‘ç»œæƒé‡çš„å‡½æ•°
def init_weights(m):
    if type(m) == nn.Linear:
        nn.init.xavier_uniform_(m.weight)

# ä¸€ä¸ªç®€å•çš„å¤šå±‚æ„ŸçŸ¥æœº
def get_net():
    net = nn.Sequential(nn.Linear(4, 10),
                        nn.ReLU(),
                        nn.Linear(10, 1))

    net.apply(init_weights)
    return net

def evaluate_loss(net, data_iter, loss):
    """è¯„ä¼°ç»™å®šæ•°æ®é›†ä¸Šæ¨¡å‹çš„æŸå¤±"""
    metric = [0.0] * 2 # æŸå¤±çš„æ€»å’Œ,æ ·æœ¬æ•°é‡
    for X, y in data_iter:
        out = net(X)
        y = y.reshape(out.shape)
        l = loss(out, y)
        metric = [a+float(b) for a,b in zip(metric,[l.sum(), l.numel()])]
    return metric[0] / metric[1]

def train(net, train_iter, loss, epochs, lr):
    trainer = torch.optim.Adam(net.parameters(), lr)
    for epoch in range(epochs):
        for X, y in train_iter:
            trainer.zero_grad()
            l = loss(net(X), y)
            l.sum().backward()
            trainer.step()
        # è¿™ä¸ªä»£ç é€»è¾‘æ²¡é—®é¢˜ï¼Œä½†æ˜¯åœ¨ä½¿ç”¨evaluate_lossæ—¶åº”è¯¥ç”¨æµ‹è¯•é›†ï¼Œè¯¥éƒ¨åˆ†ä¾‹å­æ²¡æœ‰ç»™å‡ºæµ‹è¯•é›†ï¼Œä½†æ˜¯è€ƒè™‘åˆ°è¿™éƒ¨åˆ†åªæ˜¯ä¾‹å­ï¼Œè¿™é‡Œç”¨è®­ç»ƒé›†ä¹Ÿæ— æ‰€è°“äº†ï¼ŒçŸ¥é“å°±è¡Œ
        print(f'epoch {epoch + 1},' f'loss: {evaluate_loss(net, train_iter, loss):f}')

def main():
    """ä¸»å‡½æ•°ï¼ŒåŒ…å«æ‰€æœ‰éœ€è¦æ‰§è¡Œçš„ä»£ç """
    print("ğŸš€ Section01.py çš„ä¸»å‡½æ•°")
    # 8.1.2 è®­ç»ƒ
    # æ€»å…±äº§ç”Ÿ1000ä¸ªç‚¹
    T = 1000
    time = torch.arange(1, T + 1, dtype=torch.float32)
    x = torch.sin(0.01 * time) + torch.normal(0, 0.2, (T,))
    plt.figure(figsize=(6, 3))
    plt.plot(time, x)  # ç›´æ¥ä½¿ç”¨ xï¼Œä¸è¦ç”¨ [x]
    plt.xlim(1, 1000)
    plt.xlabel('time')
    plt.ylabel('x')
    plt.show()

    # å°†è¿™ä¸ªåºåˆ—è½¬æ¢ä¸ºæ¨¡å‹çš„ç‰¹å¾ï¼æ ‡ç­¾ï¼ˆfeatureâ€labelï¼‰å¯¹ã€‚
    # å°†æ—¶é—´åºåˆ—æ•°æ®è½¬æ¢ä¸ºç›‘ç£å­¦ä¹ æ ¼å¼ï¼Œç”¨äºé¢„æµ‹ä¸‹ä¸€ä¸ªæ—¶é—´æ­¥çš„å€¼ã€‚
    # ç”¨è¿‡å»4ä¸ªæ—¶é—´æ­¥é¢„æµ‹ä¸‹ä¸€ä¸ªæ—¶é—´æ­¥
    tau = 4
    # åˆ›å»ºä¸€ä¸ªå…¨é›¶çŸ©é˜µï¼Œå½¢çŠ¶ä¸º (æ ·æœ¬æ•°, ç‰¹å¾æ•°)
    """
    ä¸ºå•¥è¦æŠŠè¿‡å»T-4ä¸ªæ—¶é—´æ­¥æ ·æœ¬æ•°, è¿‡å»4ä¸ªæ—¶é—´æ­¥å½“ä½œç‰¹å¾æ•°ï¼Ÿ
    å‡è®¾æœ‰10å¤©çš„è‚¡ç¥¨ä»·æ ¼æ•°æ®ï¼š
    x = [100, 102, 101, 103, 105, 104, 106, 108, 107, 109]  # 10å¤©ä»·æ ¼
    T = 10, tau = 4
    å¯ä»¥åˆ›å»ºå¤šå°‘ä¸ªè¿™æ ·çš„æ ·æœ¬ï¼Ÿ
    æ—¶é—´:  0   1   2   3   4   5   6   7   8   9
    ä»·æ ¼: 100 102 101 103 105 104 106 108 107 109
    
    æ ·æœ¬1: [100,102,101,103] â†’ 105  (ç”¨ç¬¬0-3å¤©é¢„æµ‹ç¬¬4å¤©)
    æ ·æœ¬2: [102,101,103,105] â†’ 104  (ç”¨ç¬¬1-4å¤©é¢„æµ‹ç¬¬5å¤©)  
    æ ·æœ¬3: [101,103,105,104] â†’ 106  (ç”¨ç¬¬2-5å¤©é¢„æµ‹ç¬¬6å¤©)
    æ ·æœ¬4: [103,105,104,106] â†’ 108  (ç”¨ç¬¬3-6å¤©é¢„æµ‹ç¬¬7å¤©)
    æ ·æœ¬5: [105,104,106,108] â†’ 107  (ç”¨ç¬¬4-7å¤©é¢„æµ‹ç¬¬8å¤©)
    æ ·æœ¬6: [104,106,108,107] â†’ 109  (ç”¨ç¬¬5-8å¤©é¢„æµ‹ç¬¬9å¤©)
    
    æ€»å…±åˆ›å»ºäº† 10 - 4 = 6 ä¸ªæ ·æœ¬
    æ¯ä¸ªæ—¶é—´æ­¥çš„æ ·æœ¬å’Œç‰¹å¾éƒ½æ˜¯ä¸ä¸€æ ·çš„ã€‚
    æ ·æœ¬1ï¼ˆå¯¹åº”é¢„æµ‹ç¬¬4å¤©ï¼‰
    # ç‰¹å¾ = è¿‡å»4å¤©çš„ä»·æ ¼
    ç‰¹å¾: [ç¬¬0å¤©=100, ç¬¬1å¤©=102, ç¬¬2å¤©=101, ç¬¬3å¤©=103]
    # æ ‡ç­¾ = è¦é¢„æµ‹çš„ä»·æ ¼
    æ ‡ç­¾: ç¬¬4å¤© = 105
    # å«ä¹‰ï¼šç”¨ç¬¬0-3å¤©çš„ä»·æ ¼é¢„æµ‹ç¬¬4å¤©çš„ä»·æ ¼
    æ ·æœ¬6ï¼ˆå¯¹åº”é¢„æµ‹ç¬¬9å¤©ï¼‰
    ç‰¹å¾: [ç¬¬5å¤©=104, ç¬¬6å¤©=106, ç¬¬7å¤©=108, ç¬¬8å¤©=107]
    æ ‡ç­¾: ç¬¬9å¤© = 109
    """
    features = torch.zeros((T - tau, tau))
    # ä¸ºç‰¹å¾çŸ©é˜µçš„æ¯ä¸€åˆ—å¡«å……å¯¹åº”åç§»é‡çš„æ—¶é—´åºåˆ—æ•°æ®ï¼Œä»è€Œè‡ªåŠ¨åˆ›å»ºå‡ºæ‰€æœ‰å¯èƒ½çš„æ»‘åŠ¨çª—å£æ ·æœ¬ã€‚
    # è¿™é‡Œæ˜¯ä¸€åˆ—ä¸€åˆ—çš„ç»™ç‰¹å¾è¿›è¡Œèµ‹å€¼ï¼Œæˆ‘è§‰å¾—æœ‰ç‚¹æŠ½è±¡
    """for i in range(tau):
        features[:, i] = x[i: T - tau + i]"""
    # ä¸‹é¢å°†ç”¨ä¸€è¡Œä¸€è¡Œèµ‹å€¼
    # ä¸€è¡Œä¸€è¡Œå¡«å……
    for i in range(T - tau):
        features[i, :] = x[i: i + tau]

    # åˆ›å»ºæ—¶é—´åºåˆ—é¢„æµ‹çš„æ ‡ç­¾ï¼ˆç›®æ ‡å€¼ï¼‰
    """
    x = [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9]  # é•¿åº¦ T=10
    tau = 4  # ç”¨è¿‡å»4ä¸ªæ—¶é—´æ­¥é¢„æµ‹ä¸‹1ä¸ªæ—¶é—´æ­¥
    x[tau:] = x[4:] = [x4, x5, x6, x7, x8, x9]
    reshape((-1, 1)) = è‡ªåŠ¨è®¡ç®—è¡Œæ•°ï¼Œå›ºå®š1åˆ—ï¼Œ-1çš„å«ä¹‰ï¼šè‡ªåŠ¨è®¡ç®—è¯¥ç»´åº¦çš„å¤§å°
    # ç‰¹å¾çŸ©é˜µ (6ä¸ªæ ·æœ¬, æ¯ä¸ªæ ·æœ¬4ä¸ªç‰¹å¾)
    features = [
        [x0, x1, x2, x3],  # æ ·æœ¬0çš„ç‰¹å¾
        [x1, x2, x3, x4],  # æ ·æœ¬1çš„ç‰¹å¾
        [x2, x3, x4, x5],  # æ ·æœ¬2çš„ç‰¹å¾
        [x3, x4, x5, x6],  # æ ·æœ¬3çš„ç‰¹å¾
        [x4, x5, x6, x7],  # æ ·æœ¬4çš„ç‰¹å¾
        [x5, x6, x7, x8]   # æ ·æœ¬5çš„ç‰¹å¾
    ]    
    # æ ‡ç­¾å‘é‡ (6ä¸ªç›®æ ‡å€¼)
    labels = [
        [x4],  # æ ·æœ¬0è¦é¢„æµ‹çš„ç›®æ ‡
        [x5],  # æ ·æœ¬1è¦é¢„æµ‹çš„ç›®æ ‡  
        [x6],  # æ ·æœ¬2è¦é¢„æµ‹çš„ç›®æ ‡
        [x7],  # æ ·æœ¬3è¦é¢„æµ‹çš„ç›®æ ‡
        [x8],  # æ ·æœ¬4è¦é¢„æµ‹çš„ç›®æ ‡
        [x9]   # æ ·æœ¬5è¦é¢„æµ‹çš„ç›®æ ‡
    ]
    """
    labels = x[tau:].reshape((-1, 1))

    batch_size, n_train = 16, 600
    # åªæœ‰å‰n_trainä¸ªæ ·æœ¬ç”¨äºè®­ç»ƒ
    train_iter = load_array((features[:n_train], labels[:n_train]), batch_size, is_train=True)
    # å¹³æ–¹æŸå¤±ã€‚æ³¨æ„ï¼šMSELossè®¡ç®—å¹³æ–¹è¯¯å·®æ—¶ä¸å¸¦ç³»æ•°1/2
    loss = nn.MSELoss(reduction='none')
    # å‡†å¤‡è®­ç»ƒæ¨¡å‹
    net = get_net()
    train(net, train_iter, loss, 5, 0.01)

    # 8.1.3 é¢„æµ‹
    # æ£€æŸ¥æ¨¡å‹é¢„æµ‹ä¸‹ä¸€ä¸ªæ—¶é—´æ­¥çš„èƒ½åŠ›ï¼Œä¹Ÿå°±æ˜¯å•æ­¥é¢„æµ‹ï¼ˆoneâ€stepâ€ahead predictionï¼‰
    onestep_preds = net(features)
    plot_single_step_predictions(time, x, onestep_preds, tau)

    # å¯¹äºç›´åˆ°xtçš„è§‚æµ‹åºåˆ—ï¼Œå…¶åœ¨æ—¶é—´æ­¥t + kå¤„çš„é¢„æµ‹è¾“å‡ºxË†t+k ç§°ä¸ºkæ­¥é¢„æµ‹
    # æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨æˆ‘ä»¬è‡ªå·±çš„é¢„æµ‹ï¼ˆè€Œä¸æ˜¯åŸå§‹æ•°æ®ï¼‰æ¥è¿›è¡Œå¤šæ­¥é¢„æµ‹ã€‚
    multistep_preds = torch.zeros(T)
    multistep_preds[: n_train + tau] = x[: n_train + tau]
    for i in range(n_train + tau, T):
        multistep_preds[i] = net(multistep_preds[i - tau:i].reshape((1, -1)))
    # ç”±äºè¯¯å·®çš„ç´¯ç§¯ï¼Œè¯¯å·®å¯èƒ½ä¼šç›¸å½“å¿«åœ°åç¦»çœŸå®çš„è§‚æµ‹ç»“æœã€‚
    plot_predictions(time, x, onestep_preds, multistep_preds, n_train, tau)

    """
    é€’å½’é¢„æµ‹ï¼ˆRolling Predictionï¼‰: 
    ä½¿ç”¨çœŸå®æ•°æ® â†’ é¢„æµ‹1æ­¥ â†’ ä½¿ç”¨é¢„æµ‹å€¼+çœŸå®æ•°æ® â†’ é¢„æµ‹ä¸‹ä¸€æ­¥ â†’ ...
    ç›´æ¥å¤šæ­¥é¢„æµ‹ï¼ˆDirect Multi-step Predictionï¼‰:
    ä½¿ç”¨çœŸå®æ•°æ® â†’ ç›´æ¥é¢„æµ‹æœªæ¥max_stepsæ­¥
    
    å…·ä½“ä¾‹å­è¯´æ˜
    tau = 3ï¼ˆç”¨3å¤©å†å²æ•°æ®ï¼‰
    max_steps = 2ï¼ˆé¢„æµ‹æœªæ¥2å¤©ï¼‰
    æ•°æ®ï¼š[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    æ ·æœ¬1: è¾“å…¥[1,2,3] â†’ è¾“å‡º[4,5]    â† é¢„æµ‹4,5
    æ ·æœ¬2: è¾“å…¥[2,3,4] â†’ è¾“å‡º[5,6]    â† é¢„æµ‹5,6  
    æ ·æœ¬3: è¾“å…¥[3,4,5] â†’ è¾“å‡º[6,7]    â† é¢„æµ‹6,7
    æ ·æœ¬4: è¾“å…¥[4,5,6] â†’ è¾“å‡º[7,8]    â† é¢„æµ‹7,8
    æ ·æœ¬5: è¾“å…¥[5,6,7] â†’ è¾“å‡º[8,9]    â† é¢„æµ‹8,9
    æ ·æœ¬6: è¾“å…¥[6,7,8] â†’ è¾“å‡º[9,10]   â† é¢„æµ‹9,10
    """
    """
    é—®é¢˜ï¼šä¹Ÿå°±æ˜¯
    æ ·æœ¬1: è¾“å…¥[1,2,3] â†’ è¾“å‡º[4,5]    â† é¢„æµ‹4,5
    æ ·æœ¬2: è¾“å…¥[2,3,4] â†’ è¾“å‡º[5,6]    â† é¢„æµ‹5,6  
    æ ·æœ¬3: è¾“å…¥[3,4,5] â†’ è¾“å‡º[6,7]    â† é¢„æµ‹6,7
    æ ·æœ¬4: è¾“å…¥[4,5,6] â†’ è¾“å‡º[7,8]    â† é¢„æµ‹7,8
    æ ·æœ¬5: è¾“å…¥[5,6,7] â†’ è¾“å‡º[8,9]    â† é¢„æµ‹8,9
    æ ·æœ¬6: è¾“å…¥[6,7,8] â†’ è¾“å‡º[9,10]   â† é¢„æµ‹9,10
    è¿™é‡Œé¢çš„æ•°æ®ï¼š[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]éƒ½æ˜¯å†å²çŸ¥é“çš„çœŸå®å€¼ï¼Œ
    åªæ˜¯ä¸ºäº†å¯»æ‰¾è§„å¾‹ï¼Œå¦‚æœæƒ³è¦é¢„æµ‹æœªæ¥çš„4ä¸ªå€¼ï¼Œæ¯”å¦‚11ï¼Œ12ï¼Œ13ï¼Œ14ï¼Œå°±éœ€è¦æ ¹æ®é¢„æµ‹çš„æ¨¡å‹ï¼Œ
    ä¼ å…¥è¾“å‡ºæ•°æ®[8,9,10]è¿™ä¸‰ä¸ªå†å²å€¼æ¥é¢„æµ‹æ˜¯å—ï¼Ÿ
    é‚£å¦‚æœæˆ‘è¦åœ¨å·²ç»é¢„æµ‹çš„11ï¼Œ12ï¼Œ13ï¼Œ14åŸºç¡€ä¸Šå†æ¬¡é¢„æµ‹æœªæ¥ä¸‰ä¸ªå€¼14,15,16ï¼Œ
    é‚£éœ€è¦ç»™æ¨¡å‹ä¼ å…¥å“ªäº›è¾“å…¥æ•°æ®ï¼Ÿ
    ç­”æ¡ˆï¼šç¬¬ä¸€ä¸ªé—®é¢˜ï¼š# ä½¿ç”¨è®­ç»ƒå¥½çš„æ¨¡å‹é¢„æµ‹æœªæ¥4æ­¥
    predicted_1 = model.predict([8, 9, 10])  # è¾“å‡º: [11, 12, 13, 14]ï¼Œå’Œæˆ‘æƒ³çš„ä¸€æ ·ã€‚
    ç¬¬äºŒä¸ªé—®é¢˜ï¼Œå¦‚æœç»§ç»­é¢„æµ‹æœªæ¥çš„ç¬¬5ï¼Œ6ï¼ˆå³15, 16ï¼‰æ€ä¹ˆåŠï¼Ÿè¿™é‡Œæœ‰ä¸¤ç§ç­–ç•¥ï¼š
    ç­–ç•¥1ï¼šä½¿ç”¨çœŸå®æ•°æ® + é¢„æµ‹æ•°æ®ï¼ˆæ··åˆè¾“å…¥ï¼‰
    è¾“å…¥ = [9, 10, 11]  # 10æ˜¯çœŸå®å€¼ï¼Œ11æ˜¯é¢„æµ‹å€¼
    è¾“å‡º = [12, 13, 14]  # é¢„æµ‹
    é—®é¢˜ï¼šæ¨¡å‹åœ¨è®­ç»ƒæ—¶ä»æœªè§è¿‡"é¢„æµ‹å€¼"ä½œä¸ºè¾“å…¥ï¼Œå¯èƒ½å¯¼è‡´è¯¯å·®ç´¯ç§¯ã€‚
    ç­–ç•¥2ï¼šåªä½¿ç”¨é¢„æµ‹æ•°æ®ï¼ˆå®Œå…¨é€’å½’ï¼‰
    è¾“å…¥ = [11, 12, 13]  # å…¨éƒ¨æ˜¯ä¸Šä¸€æ¬¡çš„é¢„æµ‹å€¼
    è¾“å‡º = [14, 15, 16]  # æ–°çš„é¢„æµ‹
    é—®é¢˜ï¼šè¯¯å·®ä¼šè¿›ä¸€æ­¥ç´¯ç§¯ï¼Œå› ä¸ºè¾“å…¥æœ¬èº«å°±æœ‰è¯¯å·®ã€‚

    æœ€ç¨³å¦¥çš„åšæ³•ï¼šæ ¹æ®ä½ çš„ tau=3ï¼Œè®­ç»ƒä¸€ä¸ªèƒ½ç›´æ¥é¢„æµ‹ max_steps=7 çš„æ¨¡å‹ï¼Œ
    ä¸€æ¬¡æ€§é¢„æµ‹ [11,12,13,14,15,16,17]ï¼Œè€Œä¸æ˜¯åˆ†ä¸¤æ¬¡é¢„æµ‹ã€‚
    æ¨èçš„å®è·µæ–¹æ³•
    æ–¹æ³•Aï¼šè®­ç»ƒå¤šæ­¥é¢„æµ‹æ¨¡å‹ï¼Œç›´æ¥è®­ç»ƒä¸€ä¸ªèƒ½é¢„æµ‹æ›´å¤šæ­¥çš„æ¨¡å‹ï¼š
    # è®­ç»ƒæ—¶ï¼šè¾“å…¥[1,2,3] â†’ è¾“å‡º[4,5,6,7,8,9,10]  # é¢„æµ‹7æ­¥
    # é¢„æµ‹æ—¶ï¼šè¾“å…¥[8,9,10] â†’ ç›´æ¥è¾“å‡º[11,12,13,14,15,16,17]
    
    æ–¹æ³•Bï¼šä½¿ç”¨æ»‘åŠ¨çª—å£é‡æ–°é¢„æµ‹ï¼Œæ¯æ¬¡éƒ½ç”¨æœ€æ–°çš„çœŸå®æ•°æ®é‡æ–°é¢„æµ‹ï¼š
    ç¬¬1å¤©ï¼šç”¨[8,9,10]é¢„æµ‹[11,12,13,14]
    ç¬¬2å¤©ï¼šçœŸå®æ•°æ®11åˆ°æ¥äº†ï¼Œç”¨[9,10,11]é‡æ–°é¢„æµ‹[12,13,14,15]
    ç¬¬3å¤©ï¼šçœŸå®æ•°æ®12åˆ°æ¥äº†ï¼Œç”¨[10,11,12]é‡æ–°é¢„æµ‹[13,14,15,16]

    æ–¹æ³•Cï¼šä¸“é—¨è®­ç»ƒé€’å½’é¢„æµ‹æ¨¡å‹ï¼Œåœ¨è®­ç»ƒæ—¶å°±æ¨¡æ‹Ÿé€’å½’åœºæ™¯ï¼š
    è®­ç»ƒæ ·æœ¬1: è¾“å…¥[1,2,3] â†’ è¾“å‡º[4]
    è®­ç»ƒæ ·æœ¬2: è¾“å…¥[2,3,4] â†’ è¾“å‡º[5]  
    è®­ç»ƒæ ·æœ¬3: è¾“å…¥[3,4,5] â†’ è¾“å‡º[6]
    """
    # åŸºäºk = 1, 4, 16, 64ï¼Œé€šè¿‡å¯¹æ•´ä¸ªåºåˆ—é¢„æµ‹çš„è®¡ç®—ï¼Œæ›´ä»”ç»†åœ°çœ‹ä¸€ä¸‹kæ­¥é¢„æµ‹çš„å›°éš¾ã€‚
    max_steps = 64
    features = torch.zeros((T - tau - max_steps + 1, tau + max_steps))
    # åˆ—iï¼ˆi<tauï¼‰æ˜¯æ¥è‡ªxçš„è§‚æµ‹ï¼Œå…¶æ—¶é—´æ­¥ä»ï¼ˆiï¼‰åˆ°ï¼ˆi+T-tau-max_steps+1ï¼‰
    for i in range(tau):
        features[:, i] = x[i: i + T - tau - max_steps + 1]
    # åˆ—iï¼ˆi>=tauï¼‰æ˜¯æ¥è‡ªï¼ˆi-tau+1ï¼‰æ­¥çš„é¢„æµ‹ï¼Œå…¶æ—¶é—´æ­¥ä»ï¼ˆiï¼‰åˆ°ï¼ˆi+T-tau-max_steps+1ï¼‰
    # é€’å½’é¢„æµ‹
    # i = tau æ—¶ï¼šç”¨ features[:, 0:tau]ï¼ˆçœŸå®æ•°æ®ï¼‰é¢„æµ‹ç¬¬ tau åˆ—
    # i = tau+1 æ—¶ï¼šç”¨ features[:, 1:tau+1]ï¼ˆåŒ…å«ä¸Šä¸€æ­¥çš„é¢„æµ‹å€¼ï¼‰é¢„æµ‹ç¬¬ tau+1 åˆ—
    """
    ä¸‹é¢é‚£ä¸ªå¾ªç¯æ˜¯é€’å½’é¢„æµ‹ï¼Œä¸æ˜¯ç›´æ¥å¤šæ­¥é¢„æµ‹ï¼šæ²¡æœ‰è®­ç»ƒæ¨¡å‹ç›´æ¥è¾“å‡ºå¤šä¸ªæ—¶é—´æ­¥
    æ˜¯å•æ­¥æ¨¡å‹çš„é€’å½’åº”ç”¨ï¼šç”¨åŒä¸€ä¸ªå•æ­¥é¢„æµ‹æ¨¡å‹åå¤é¢„æµ‹
    ä¼˜ç‚¹ï¼š
    çµæ´»æ€§ï¼šå¯ä»¥é¢„æµ‹ä»»æ„æ­¥æ•°ï¼ˆåªè¦å¾ªç¯è¶³å¤Ÿå¤šæ¬¡ï¼‰ 
    ä¸€è‡´æ€§ï¼šå§‹ç»ˆä½¿ç”¨ç›¸åŒçš„å•æ­¥é¢„æµ‹æ¨¡å‹   
    å†…å­˜æ•ˆç‡ï¼šä¸éœ€è¦ä¸ºä¸åŒæ­¥æ•°è®­ç»ƒå¤šä¸ªæ¨¡å‹    
    ç¼ºç‚¹ï¼š
    è¯¯å·®ç´¯ç§¯ï¼šæ—©æœŸçš„é¢„æµ‹è¯¯å·®ä¼šå½±å“åç»­æ‰€æœ‰é¢„æµ‹   
    åˆ†å¸ƒåç§»ï¼šæ¨¡å‹åœ¨è®­ç»ƒæ—¶åªè§è¿‡çœŸå®æ•°æ®ï¼Œé¢„æµ‹æ—¶å´è¦å¤„ç†é¢„æµ‹å€¼
    """
    for i in range(tau, tau + max_steps):
        features[:, i] = net(features[:, i - tau:i]).reshape(-1)
    steps = (1, 4, 16, 64)
    # ä½¿ç”¨ä¿®å¤ç‰ˆå‡½æ•°
    plot_multistep_predictions_fixed(time, features, steps, tau, max_steps)


if __name__ == '__main__':
    main()
